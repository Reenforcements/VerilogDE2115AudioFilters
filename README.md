

#Digital Filters and Audio Effects on the DE2-115 FPGA
##Austyn Larkin

##Description

##Background Information
---
Audio is often transmitted as an **analog signal**. The DE2-115 board is equipped with several **3.5mm audio connectors** that can be utilized to input and output analog audio from the board. These are the same kind connectors running the same kinds of **analog audio signals** you'd find on a laptop or phone.
![Sample analog audio signals](http://i.imgur.com/aI0B9Tq.png)
######A picture of an analog audio signal
The first step to applying effects to audio is getting the audio to the FPGA. When a source of audio is connected to the **Line-in audio jack**, it's sending an analog signal. Now, the FPGA can only work with **digital signals**. This means the signal is represented as a stream of binary numbers. Each of these numbers is called a **sample**.
![A closeup of an analog signal](http://i.imgur.com/2pZBpMt.png)
######An extreme closeup of a digitalized analog audio signal. Each point represents a single sample.

This is where the **Wolfson WM8731** IC (integrated circuit) comes into play. This IC has the ability to convert an analog signal to the stream of digital samples the FPGA can use. These samples don't stay on the FPGA for long. As soon as the FPGA modifies them, using something called a **digital filter**,  they're sent back to the **Wolfson** IC. The IC then converts these digital samples back to an analog signal and sends the signal to the **Line-out audio jack**. From there, any standard audio output device such as headphones or speakers can be connected to hear the modified sound.



##The Design
---
When the Wolfson IC is powered on, it's not ready to send and receive digital audio samples. It has to be **initialized** by the FPGA. So, the first step in implementing the project was understanding how to make the FPGA talk to the **Wolfson** IC. In general, are many different **protocols** that IC's use to talk to each other. These are equivalent to the different spoken lanuages that exist throughout the world. The Wolfson IC only understands a protocol called **I<sup>2</sup>C**, which stands for **inter-integrated circuit**. In order for the FPGA to talk to the Wolfson, it had to be taught how to speak I<sup>2</sup>C.

####I<sup>2</sup>C

Here is a brief overview on how I<sup>2</sup>C works: The protocol requires two connections between the FPGA and the Wolfson IC: a **data line (SDIN)** and a **serial clock line (SCLK)**. The Wolfson is specified as a **slave only device**, meaning it just listens to what it's told to do. This means the FPGA will do most all the talking. In I<sup>2</sup>C, the data line is shared. One chip will send **8 bits of data**, and then will listen for a **1 bit** reply from the other chip. This single bit reply is called the **ACK bit (acknowledge bit)** and tells the sender that the data was received. The purpose of the clock line is to tell the listening chip exactly when to listen. The listening chip will only read a bit of data when the clock line goes from **low to high**.

![A diagram of the protocol](http://i.imgur.com/2imuBRP.png)
######A diagram of the I<sup>2</sup>C protocol taken from the [Wolfson's data sheet](https://www.rockbox.org/wiki/pub/Main/DataSheets/WM8731_8731L.pdf)

Once a module was created to allow the FPGA to speak I<sup>2</sup>C, the Wolfson IC could then be initialized. The FPGA uses I<sup>2</sup>C to write to the **registers** of the Wolfson IC. These registers are akin to very simple "preferences". The FPGA has to write to these registers to control and initialize things on the Wolfson IC such as digital audio format, which parts of the chip to power up,  when to start listening and converting analog audio to digital, ect.

####Sending and receving audio between the FPGA and the Wolfson

Once the Wolfson IC is initialized, it needs a clock signal so it can start sending and receiving digital audio to and from the FPGA. According to the data sheet, the Wolfson IC can generate its own clock. It was found, however, that the audio chip only seemed to work when a 12.288Mhz clock was generated by the FPGA and sent to the Wolfson on its **AUD_XCK** pin. This clock was generated by the **Audio Clock for DE-series Boards** IP module in Quartus. 

Once the Wolfson IC had a clock, it was able to send and receive digital audio over the appropriate lines. For receiving digital audio samples from the Wolfson's **ADC (analog to digital converter)**, the **AUD_ADCDAT** and **AUD_ADCLRCK** pins were used. For sending digital audio samples to the **DAC (digital to analog converter)**, the **AUD_DACDAT** and **AUD_DACLRCK** pins were used. The Wolfson IC was initialized to used **16 bit audio samples**. This means that in each pair of left and right samples, a total of **32 bits were used**. As shown in the diagram below, the bits are read/written one at a time starting with the **most significant bit** and moving towards the **least significant bit**. This is done for the left and right channels in sequence until all the bits are read/written in. Each of the bits are read in on the **AUD_BCLK**. This clock runs at 64 times the audio sample rate. In this case, the clock ran at about 64*48,000 ~= 3Mhz. 

![Sending and receving audio from the Wolfson IC](http://i.imgur.com/MicVc7Y.png)
######A diagram of sending/receiving digital audio samples from the Wolfson IC, taken from the [Wolfson's data sheet](https://www.rockbox.org/wiki/pub/Main/DataSheets/WM8731_8731L.pdf)

####Visualizer
A simple visualizer was created to show the current volume of the audio passing through the board. The louder the sound, the more LEDs in a row were lit up. The following algorithm was used:
```C
averaged = ((left + right) / 32'd2);
for(i = 0; i < 16; i = i + 1)
begin
leds[i] = ( averaged > (2048*i) ) ? 1'b1 : 1'b0;
end
```

####Digital Filters
Once a stream of samples was running through the FPGA, all that was left to do was modify them on their way to the DAC. This was accomplished using **digital filters**, which operate on the digital samples coming into the FPGA from the Wolfson IC. Three filters were implemented: Low pass, high pass, and mid pass. 

A low pass filter allows low freqency sounds to pass through unhindered while attenuating higher frequency sounds. If you pass music through a low pass filter, it will sound very "deep" and bass-like.

A high pass filter is similar, but it only allows higher frequency sounds to pass through and attenuates lower frequency sounds. This results in audio that sounds very "tinny".

The mid pass filter is somewhat of a mix between the two. It only allows mid-frequency sounds to pass through while attenuating low and high frequency sounds. Because it allows a range of frequencies to pass through, this filter is usually called a **band pass filter**.

Each of the following pseudocodes were implemented in C before being implemented on the FPGA in order to test the code and tune the constants.

The **mid pass** filter was based off the following pseudocode from [Wikipedia](https://en.wikipedia.org/wiki/Low-pass_filter).
```javascript
function lowpass(real[0..n] x, real dt, real RC)
var real[0..n] y
var real α := dt / (RC + dt)
y[0] := x[0]
for i from 1 to n
y[i] := α * x[i] + (1-α) * y[i-1]
return y
```

The **high pass** filter was also based off pseudocode from [Wikipedia](https://en.wikipedia.org/wiki/High-pass_filter).
```javascript
function highpass(real[0..n] x, real dt, real RC)
var real[0..n] y
var real α := RC / (RC + dt)
y[0] := x[0]
for i from 1 to n
y[i] := α * y[i-1] + α * (x[i] - x[i-1])
return y
```

The **mid pass** filter was implemented using both the high pass and low pass filter by [feeding the result of the low pass filter into the high pass filter.](https://books.google.com/books?id=k8SSLy-FYagC&pg=PA260&dq=band-pass-filter#v=onepage&q=band-pass-filter&f=false)

For each of the implemented filter modules, the 16 bit left and right audio channels were expanded to 32 bits to avoid any overflow while multiplying/dividing the audio by integer constants. The resulting calculuations were then truncated back to 16 bits and sent to the DAC.

##Results
---
The results were pretty good. The filters weren't top quality but they worked!

####Visualizer
Here's a little sample of what the visualizer looks like when you play music through the board.
![Visualizer Results](http://i.imgur.com/Ace3hHC.gif)

####Filters
For a demonstration of the filters, please see the "AudioSample.wav" in the root directory of the project. The progression of the filters is: unfiltered, high pass, low pass, mid pass, and unfiltered.

##Citations
Citations were made throughout the document with appropriate links. A full list of sources consulted while developing this project are as follows:
https://en.wikipedia.org/wiki/Low-pass_filter

https://en.wikipedia.org/wiki/High-pass_filter

http://www.dspguide.com/ch14/5.htm

https://kiritchatterjee.wordpress.com/2014/11/10/a-simple-digital-low-pass-filter-in-c/

https://books.google.com/books?id=k8SSLy-FYagC&pg=PA260&dq=band-pass-filter#v=onepage&q=band-pass-filter&f=false
